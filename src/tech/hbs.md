# JS 高级程序设计阅读指南
带着问题看书，学习效率更高~

## 一至三章
1.1一个完整的js实现包括啥？
ECMAscript, DOM, BOM

1.2ECMA的宿主环境有？
Web浏览器, node, flash, webview

1.3为何要DOM?
确保代码可以跨平台使用,

1.4DOM各级的区别？
1级映射文档结构,
2级事件和支持CSS
3级加载和保存文档的方法

1.5BOM的作用是？
让js可以控制页面以外的部分

2.1带src属性的script元素与其闭合标签嵌入JS代码有何问题？
被忽略，不执行

2.2如何避免包含太多JS代码页面的空白？
js引用放在body页面后面

2.3为何最好一个页面 只 包含一个延迟脚本？
因为延迟脚本不一定按顺序执行；

2.4为何建议异步脚本最好不要在加载期间修改DOM?
因为页面会先于脚本加载页面，容易出问题

2.5noscript元素中的内容何时出现？
浏览器不支持脚本或者脚本被禁用

3.1为何要用严格模式？
避免 不确定行为和不安全的操作。

3.2省略分号有何隐患？
容易带来错误和降低性能（解析器需要推测）

3.3在控制语句中使用代码块的好处？
让编码意图清晰和降低修改代码出错的几率

3.4为何说JS的变量是松散类型的？
因为变量仅是保存值得占位符，可用来保存任何类型的数据

3.5js的数据类型有？
基本类型：undefined，null，Number，Boolean，String
引用类型 Object

3.6typeof的作用？
检测变量的数据类型

3.7typeof的返回值有？
undefined，number，boolean，string, object, function

3.8引入undefined的目的是？
区分空对象指针与未初始化的变量

3.9对未声明变量只能执行的操作是？
typeof检测其类型

3.10为何建议显示初始化变量？
便于使用typeof区分变量是未声明还是未初始化

3.11null值表示什么？
空对象指针

3.12为何把变量显示初始化为undefined没必要，而把对象初始化为null却又必要？
体现null作为空指针的惯例，
进一步区分null和undefined

3.13Boolean的字面值区分大小写吗？
区分，所以False, 与false 不一样

3.140.1+0.2不等于0.3?
浮点数的精度是17位，存在舍入误差

3.15如何理解NaN？
表示一个本来要返回数值的操作数未返回数值的情况

3.16JS中除0会阻止代码的执行吗？
不会，因为它返回了NaN

3.17对象调用isNaN()函数有何不同？
先调用valueOf()进行判断，视情况再调用toString()进行判断

3.18数值转型函数Number与parseInt/parseFloat有何区别？
前者针对任何类型，后两者只针对字符串

3.19parseInt和parseFloat有何区别？
一是parseFloat不忽略第一个小数点；
二是parseFloat始终忽略前导0；
三是parseFloat只解析十进制；

3.20怎样避免parseInt错误解析字符串？
任何情况下明确基数。

3.21Number与parseInt解析空字符串时有何区别？
前者返回 0， 后者返回NaN

3.22转换为字符串的方法及区别？
toString()通过指定基数，改变输出的值，null和undefined没有toString方法()
String()将任何类型的值转换成字符串

3.23如何改变数值的toString()方法的 返回值？
传入指定基数

3.24为何说Object是所有实例的基础？
Object所具有的任何属性和方法也存在于具体对象中。

3.25递增/减前置和后置的区别？
前置时变量在语句执行前改变，后置则是在语句执行后改变

3.26系统怎样对 非数值 应用 位操作符 进行自动处理？
使用Number()函数把该值转换为数值

3.27如何理解短路操作？
第一个数决定结果，则不会操作第二个数

3.28比较数值与字符串时是如何转换的？
字符串转换为数值

3.29任何操作数与NaN的比较结果是？
flase

3.30相等和全等的区别？
全等不需要转换，性能更好

3.31为何NaN不等于NaN？
逻辑上设计如此

3.32逗号操作符的赋值规则是？
返回表达式最后一项

3.33为何for...in循环输出的属性名不可预测？
Js对象属性没没有顺序，

3.34为何不建议大量使用with语句？
性能下降，调试困难

3.35为何switch语句比较时不发生转换？
使用的是全等比较

3.36为何位于 return语句后的代码不会执行？
函数执行return后会立即停止并退出

3.37JS函数中通过什么获取参数数组？
arguments对象

3.38为何JS中的函数不能实现重载？
无法做到 参数类型和数量的不同

## 四至六章
4.1 如何理解js变量松散类型本质？
这决定了js只在特定的时间用于保存特定值得名字而已，变量的值及其数据类型可以在脚本的生命周期内改变！

4.2引用类型与基本类型有什么区别？
基本类型是按值访问的，可以操作保存在变量中的实际值；引用类型的值是保存在内存中的对象，在操作对象时，实际上是在操作对象的引用，因为js不允许直接访问内存；引用类型可以为其添加属性，而基本数据类型则不可，尽管不报错；在复制变量时，基本类型是独立的两个变量，而引用类型中两个变量实际上引用的都是同一个对象，相互影响。

4.3 如何理解js中所有函数的参数都是按值传递的？
在向参数传递基本数据类型的值时，被传递的值会被复制给一个局部变量，而在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化回反应在函数的外部；在参数为对象时，如果函数内部重写对象，此时的变量引用的只是局部对象，在函数执行完立即销毁，因此不会影响传进来的 外部对象。

4.4如何检测引用类型的具体类型？使用instanceof

4.5如何理解函数的执行环境？
当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

4.6作用域链的作用是？
保证对执行环境有权访问的所有变量和函数的有序访问。

4.7作用域的头尾是？
前端始终是当前执行代码所在环境的变量对象，后端始终是全局执行环境的变量对象！

4.8延长作用域链的方法有？
使用try-catch语句的catch块或者with语句

4.9如何理解js的块级作用域？
在ES6引入let关键字之前，不存在块级作用域，所以if或者for等语句执行完后，其内部声明的变量依然会存在于外部变量之中。

4.10为何初始化变量之前，最好先声明？
一是在严格模式下，初始化未经声明的变量会导致错误；二是变量会自动被添加到全局环境，容易导致意外。

4.11如何理解js的垃圾收集机制？
使用标记清除或引用计数的收集策略，周期性的找出那些不再使用的变量，然后释放其占用的内存。

4.12如何避免采用引用计数 垃圾收集策略时出现的循环引用问题？
在不使用时，手工断开原生JS对象与DOM元素之间的连接，如将变量设置为null。

4.13为何分配给web浏览器的内存比桌面程序的少？
主要出于安全考虑，防止运行JS网页耗尽全部系统内存而导致系统崩溃。

4.14优化内存的最好方式是？
为执行中的代码只保存必要的数据，一旦不用，最好设置为null来释放其引用，让值脱离环境，以便垃圾收集器下次运行时将其回收。

4.15基本类型和引用类型在内存中的位置有何不同？
前者保存在栈内存中，后者保存在堆内存中。

5.1js中创建对象实例的方法有？
一是使用new操作符后跟Object构造函数；二是使用对象字面量表示法。

5.2如何选择访问js对象方法？
除了必须使用变量来访问属性时采用方括号表示法，其他均建议使用点表示法。

5.3js中数组类型与其他语言最大的区别是？
每一项可以保存任何类型的数据，并且数组大小是可以通过设置length属性进行动态调整的。

5.4创建数组的方式有？
使用Array构造函数法和数组字面量表示法

5.5给数组构造函数传递一个值时处理规则是？
如果传递的值时数值，则按照该数值创建给定项数的数组；如果是其他类型的，则会创建只有那一个值得数组。

5.6检测数组需要注意什么？
当存在两个以上不同全局执行环境时，instanceof会难以区分不同的数组构造函数，所以在支持Array.isArray()方法的浏览器中使用该方法。

5.7js的数组是怎么实现栈和队列的数据结构的？
使用push和pop方法模拟栈，使用shift和push，或unshift和pop模拟双向队列

5.8数组的方法有？
isArray, toLocaleString, toString, valueOf, 
push, pop, shift, unshift,
reverse, sort, 
concat, splice,
indexOf, lastIndexOf,
every, filter, forEach, map, some,
reduce, reduceRight,

5.9js中定义函数的方法有？
一是使用函数声明语法；二是使用函数表达式；三是使用Function构造函数（不推荐，解析了两次代码而影响性能）。

5.10js中函数为何没有指针？
因为每个函数实际都是Function类型对象的实例，函数名只是一个指向函数对象的指针，不会与某个函数绑定，如果申明了两个同名函数，后面的函数会覆盖前面的函数。

5.11函数声明和函数表达式的区别？
js引擎会把函数声明提升到顶部，而表达式得到解析器执行到其所在的代码行才会被解释执行。

5.12函数名本身是变量有何好处？
使得函数可以作为值来使用，传递参数或者作为函数内部的返回值等。

5.13如何理解函数内的arguments对象的callee属性？
指向拥有该arguments对象的函数本身，一般在函数递归时用来消除函数执行与函数名的耦合。

5.14函数内部的属性和方法有？
argument和this对象，length和prototype变量，apply，call和bind
toLocaleString, toString, valueOf

5.15为何用apply和call？他们的区别？
确保对象不与方法耦合的前提下，去扩充函数执行的作用域；接收参数的方式不同。

5.16Boolean, Number和String 特殊引用类型的作用是？特殊在哪？
便于操作基本类型的值；特殊在对象的生存期，使用new操作符创建的引用类型实例，会在执行流离开当前作用域前一直保存在内存中，而特殊类型只存在代码执行的瞬间，并且不能再运行时为其添加属性和方法。

5.17使用new调用基本包装类型的构造函数，与调用同名转型函数的区别？
前者返回 的类型为对象，而后者还是基本类型。

5.18String类型提供了那些方法和属性辅助js对字符串的解析和操作？
length,继承于对象的toLocaleString, toString, valueOf
charAt, charCodeAt
concat, slice, substr, subtring,
indexOf,lastIndexOf,
trim,
toLowerCase, toLocaleLowerCase, toUpperCase, toLocaleUpperCase,
match, search, replace,localeCompare,
fromCharCode

5.19Global对象的方法和属性有？
isNaN, isFinite, parseInt, parseFloat,
encodeURI, encodeURIComponent,
decodeURI, decodeURIComponent,
eval；
undefied, NaN, Infinity,Object, Array, Fuction, Boolean, String, Number

5.20为何Math对象提供的计算功能比在JS中直接编写的要快得多啊？
因为其属性和方法都是静态的，js引擎做了优化，少了解析代码的环节。

6.1js中的属性有？
数据属性和访问器属性

6.2如何修改数据属性的默认值？如何获取？
使用Object.defineProperty()方法修改；
使用Object.getOwnPropertyDescriptor()方法获取；

6.3对象如何定义多个属性？
使用Object.defineProperties()方法

6.4使用Object构造函数或对象字面量创建对象的共同缺点是？
产生大量重复代码；

6.5工厂模式解决了什么问题，还存在什么问题？
解决了创建相似对象的问题，没有解决对象识别的问题；

6.6构造函数解决了什么问题，还存在什么问题？与普通函数有何区别？
构造函数可通过其constructor属性来标识它的实例为特定的对象类型，即解决了创建相似对象问题，又解决了对象识别问题，但是每个方法都在实例重新创建了一遍，会导致不同的作用域链和标识符解析，且不同实例的同名函数不相等；
形式上是首字母大小写不同，本质上是调用方式不同，如果构造函数作为普通函数调用，属性和方法都会被添加到全局对象；

6.7函数中prototype属性的作用是？
包含可以由特定类型的所有实例共享的属性和方法，其本身也是一个对象，其constructor属性指向包含该原型的构造函数。

6.8对象实例与原型中值的规则？
实例可以访问原型中的值，却不能修改，且若实例添加了一个与原型同名的属性，将会屏蔽原型中的属性，阻止实例访问，只有通过delete操作符才能恢复去指向原型的连接。

6.9如何确定属性是实例属性还是原型属性？
同时使用hasOwnProperty()方法和in操作符；

6.10使用对象字面量重写原型对象有何问题？
其constructor属性指向Object了，需要特意将其显示的设置回特定的值，但会修改其枚举属性，所以最好使用Object.defineProperty()去单独设置；切断了构造函数与最初原型之间的联系，回导致错误。

6.11为何不推荐在原型对象中去定义新方法和属性？
可能导致命名冲突，还有就是可能意外重写原生方法。

6.12原型对象还存在的问题？
所有的属性都被所有的实例共享。

6.13怎么实现组合继承？
使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。

6.14寄生式继承为何会降低效率？
因为不能做到函数复用。。。

6.15组合继承存在的最大问题是？
总是调用两次超类函数。。。

6.16如何实现寄生组合式继承？
通过构造函数来继承属性，通过原型链和混成形式来继承方法。

## 七至九章
7.1 如何理解函数声明提升？
执行代码之前会读取函数声明，这意味着可以把函数声明放在调用它语句的后面。

7.2 匿名函数的name属性是？
空字符串

7.3 怎样实现对函数的递归调用最安全？
最好使用命名函数表达式，因为使用函数声明时进行引用赋值时，一旦将原来的函数名设置为null，就会导致错误；而使用arguments.callee代替函数名进行递归调用，在严格模式会不允许。

7.4什么是闭包？
闭包是指有权访问另一个函数作用域中变量的函数。

7.5创建闭包的常见方式？
在一个函数内部创建另一个函数。

7.6函数第一次调用时发生了什么？
创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性[[scope]],然后使用this，arguments和其他命名参数值来初始化函数的活动对象。

7.7作用域链的本质是？
一个指向变量对象的指针列表，它只引用但不实际包含变量对象。

7.8为何建议只在绝对必要时在考虑闭包？
闭包换携带包含它的函数的作用域，因此会比其他函数占用更多的内存，过度使用闭包会导致内存占用过多。

7.9匿名函数的this指向？
Window，因为它的执行环具有全局性。

7.10函数被调用时，其活动对象自动获取的特殊变量有？
this和arguments。

7.11闭包的副作用有？
只能取得函数中任何变量的最后一个值；
This指向不符合预期；
容易发生内存泄漏；

7.12如何看待重复声明变量？如何解决？
对后续声明视而不见，但会执行变量的初始化；模仿块级作用域。

7.13模仿块级作用域的技术一般用在哪？
全局作用域被用在函数外部，以限制向全局作用域中添加过多的变量和函数，从而避免命名冲突。

7.14什么是单例？
只有一个实例的对象

8.1BOM的事实标准是？
浏览器之间共有的对象

8.2window对象的双重角色是？
既是JS访问浏览器窗口的接口，又是ECMAScript规定的Global对象。

8.3定义全局变量与在window对象上直接定义属性的区别？
全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。

8.4引入 self 对象的目的是？
与top和parent对象对应起来。

8.5为何不建议给setTimeout()方法第一个参数传递字符串？
因为传递字符串可能导致性能损失。

8.6为何setTimeout()经过第二个参设置的时间后不一定会执行？
因为JS是一个单线程语言，一定时间内只能执行一段代码，如果任务队列为空，添加的代码会立即执行，若非空，就需要等前面的代码执行后再可执行。

8.7为何取消间歇调用比取消超时调用重要？
因为在不加干涉的情况下，间歇调用会一直执行下去

8.8为何location对象是BOM最有用的对象之一？
因为它提供了与当前窗口中加载文档的有关信息，还提供了一些导航功能。

8.9location对象有何特殊之处？
它既是window对象的属性，也是document对象的属性。

8.10为何要把reload()放在代码的最后一行？
因为位于reload()调用之后的代码可能会也可能不执行，这取决了网络延迟或系统资源等因素。

8.11BOM的对象有？
框架相关的top、parent、self对象
location对象、navigator对象、screen对象和history对象。

9.1什么时候使用客户端检测？
找不到更通用的方法之后，万不得以

9.2能力检测的目标是？
不是识别浏览器，而是识别浏览器的能力。

9.3能力检测需要注意什么？
尽量使用typeof进行检测，该特性是否按照适当方式进行。

9.4在实际开发中，如何应用能力检测？
应该将能力检测作为确定下一步解决方案的依据，而不是用来判断用户使用的是什么浏览器。

9.5怪癖检测的目标是？
识别浏览器的特殊行为，存在什么缺陷。

9.6用户代理适用的情形有？
不能直接准确使用能力检测或怪癖检测；
同一款浏览器在不同平台下具备不同的能力；
为了跟踪分析等目的。

9.7客户端检测方法有？
能力检测、怪癖检测和用户代理检测。

## 十至十二章
10.1 什么是DOM？
DOM是针对HTML和XML文档的一个API;

10.2在确定节点类型时，如何确保兼容性？
讲nodeType属性与数字值进行比较；

10.3为何说NodeiList是有生命、有呼吸的对象？
因为它是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。

10.4DOM中操作节点的方法有？
appendChild();insertBefore();
replaceChild();removeChild();
cloneNode();normalize();

10.5document对象获取特定某个或某组元素引用的方法有？
getElementById()和getElementsByTagName()
getElementsByName()(HTMLDocument类型有，XML类型没有)

10.6如果页面中多个元素的ID相同，getElementById()如何处理？
只返回文档中第一次出现的元素；

10.7为何最好在比较之前将标签名转换为相同的大小写形式？
因为HTML和XML中标签名大小写 规则不一样；

10.8操作特性的DOM方法有？
getAttribute();setAttribute();removeAttribute();

10.9attributes属性的方法有？
getNameItem();removeNameItem();setNameItem();item();

10.10操作节点中的文本有？
appendData();deleteData();insertData();
replaceData();splitText();substringData();

10.11什么是动态样式？
在页面加载时不存在的样式，加载后才动态添加到页面中。

10.12为何DOM操作在处理,script和style元素时存在一些复杂性？
因为这两个元素分别包含脚本和样式信息，浏览器会将他们和其他元素区别对待。

10.13如何理解DOM对性能的影响？
DOM操作往往是JS程序中开销最大的部分，因此要尽量减少对DOM的操作。

11.01选择符API的目的是？
致力于让浏览器原生支持CSS查询，让解析和树查询操作可以在浏览器内部通过编译后的代码来完成，去改善性能。

11.02querySelectorAll()和querySelector的异同？
接收的参数都是一个CSS选择符，若传入浏览器不支持的选择符或者选择符中有语法错误，都会抛出错误；
而前者返回的是所有的元素，后者只返回一个元素；

11.03返回NodeList的DOM方法杜具有的同样问题是？
性能问题

11.04Document的readyState属性的可能值有？
Loading 正在加载文档；complete已经加载完文档。

11.05如何避免在使用innerHTMl、outerHTML属性和insertAdjacentHTML()方法时可能导致的内存占用问题？
手工删除被替换元素的所有事件处理程序和JS对象属性。

11.06H5中选择的滚动页面的标准方法为？
scrollIntoView()

11.07为何要为DOM元素定义额外的属性？
因为浏览器处理DOM元素间空白符的方式不一样

12.01DOM2级和3级的目的是？
扩展DOM API，以满足操作XML的所有需求，同时提供更好的错误处理和特性检测能力。

## 十三至十五章
13.1 JS和HTML的交互式如何实现的？
通过事件实现的

13.2什么是事件流？
描述的是从页面中接收事件的顺序。

13.3什么是事件冒泡？
事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点；

13.4事件捕获的目的是？
在事件到达预订目标之前捕获它

13.5DOM2级规定事件流三阶段是？
事件捕获阶段、处于目标阶段和事件冒泡阶段。

13.6什么是事件？
用户或浏览器自身执行的某种动作。

13.7在HTML中指定事件处理程序的缺点有？
一是存在时差；二是作用域链在不同浏览器会导致不同的结果；三是HTML与JS代码紧密耦合；

13.8 DOM 2级事件定义的两个方法和参数是？
addEventListener()和removeEventListener():要处理的事件名、作为事件处理程序的函数和一个布尔值（true表示在纱布或阶段调用事件处理程序，false表示在冒泡阶段调用事件处理程序）；

13.9使用DOM 2级方法添加事件处理程序的好处是？
可以添加多个事件处理程序。

13.10为何多数时候，将事件处理程序添加到事件流的冒泡阶段？何时添加到捕获阶段？
因为这样可以最大限度地兼容各种浏览器；
只在需要在事件到达目标前截获他的时候将事件处理程序添加到捕获阶段。

13.11IE中使用attachEvent与使用DOM 0级方法的主要区别是？
事件处理程序的作用域，前者会在全局作用域，后者会在元素作用域内运行。

13.12使用addEventListener()和attachEvent()添加的匿名函数共同存在的问题是？
不能移除

13.13事件对象包含什么？
事件元素、类型和其他与特定事件相关的信息。

13.14如何理解事件对象的存活期？
在事件处理程序执行期间存在，执行结束就被销毁。

13.15web浏览器中的事件类型有？
UI事件、焦点、鼠标、滚轮、文本、键盘、合成、变动和变动名称等事件。

13.16为何在JS中添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能？
一是函数都是对象，对象会占内存，内存中对象越多，性能越差；
二是必须制定所有事件的处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间；

13.17从利用好事件处理程序的角度出发，有什么方法可以提升性能？
限制数量、事件委托、移除事件处理程序

14.1获取 form 元素引用的方式有？
一是看成与其他元素一样，使用getElementById等方法获取；
二是通过document.forms获取页面所有的表单；

14.2提交表单可能出现的最大问题是？如何解决？
重复提交表单；一是第一次提交表单后就禁用提交按钮；二是利用onsubmit事件处理程序取消后续的表单提交操作。

14.3为何在处理文本框的值时，最好不要使用DOM方法？
对value属性所做的修改，不一定会反映在DOM中。

14.4表单序列化在什么场景下使用最多？
使用Ajax请求

15.1出现在canvas元素开始和结束标签中的内容何时显示？
在浏览器不支持canvas元素时显示。

15.2在使用canvas元素之前需要干啥？
检测getContext()方法是否存在。

## 十六至十八章
16.1 什么是跨文档消息传递？
指的是来自不同域的页面间传递消息

16.2 XDM的核心是？
postMessage()方法，其接受两个参数，一条消息和一个表示消息接收方来自哪个域的字符串；

16.3 如果传给postMessage()方法的第二个参数是'*‘，意味着什么？
可以把消息发给任何域的文档

16.4 接收XMD消息时，会触发window对象的什么事件？
以异步的形式触发message事件

16.5 触发message事件后，传给onmessage处理程序的事件对象包括什么信息？
- data 作为postMessage()第一个参数传入的字符串数据；
- origin 发送消息文档的所在域；
- source 发送消息文档的Window对象代理；

16.6 为什么不同通过event.source 这个代理对象访问window的其他任何信息？
因为大多数情况下，event.source 这个代理对象并非真实的window对象

16.7 为何使用postMessage()，传入结构化数据时，建议先要在传入数据调用JSON.stringify()，在onmessage事件处理程序中调用JSON.parse()?
因为postMessage()最早第一个参数只允许传入字符串的，后来又部分浏览器支持传入结构化数据。

16.8 拖到元素时，依次触发的事件有？
dragstart -> drag -> dragend

16.9 当某个元素被拖动到一个有效的目标时，会依次发生的事件有？
dragenter -> dragover -> dragleave或drop

16.10 如何把任何元素变成有效的放置目标？
重写dragenter和dragover事件的默认行为

16.11 H5规范中引入dataTransefer的作用是？
在拖放操作时实现数据交互

16.12 H5为所有HTML元素引入的dragable属性作用是？
通过设置它来控制元素是否可以拖动

16.13 为何要用canplayType检测浏览器是否支持特定媒体格式？
因为并非所有浏览器支持所有的格式

16.14 历史状态管理器有啥用？
不必卸载当前页即可修改浏览器的历史状态栈

17.1 JS中处理异常的标准方式是？
使用try-catch语句

17.2唯一能够保证让所有浏览器都支持的错误对象属性是？
message属性

17.3 JS中ß的7中错误类型时？
Error EvalError  RangeError  referenceError   SyntaxError  TypeError  URIError

17.4 Error这个基类型的主要目的是？
供开发人员抛出自定义 错误

17.5  throw操作符的作用是？
抛出自定义的错误，必须指定一个值

## 十九至二十一章
19.1 什么是E4X?
不是一门语言，而是对ECMAScript语言的可选扩展，为处理XML定义了新的语法，也定义了特定于XML的对象。

19.2 为何xml类型继承了所有对象默认的所有属性和方法？
因为它继承自Object类型；

20.1 如何理解JSON?
它是一种数据格式，而不是一种编程语言。

20.2  JSON的语法可以表示哪三种的值？
简单值、对象和数组

20.3 JSON字符串和JS字符串的最大区别是？
JSON字符串必须使用双引号，使用单引号会导致语法错误；

20.4 JSON对象和JS对象字面量有何区别？
一是没有声明变量；二是没有末尾分号；但是JSON对象中的任何属性名任何时候都必须加双引号；

20.5 为何JSON数据格式会流行？
一是可以把JSON数据结构解析为有用的JS对象；二是与JS有类似的语法；

20.6 如何把JS对象序列化为一个JSON字符串？
使用JSON.stringify()方法

20.7 如何获得JSON字符串对应的JS值？
使用JSON.parse()方法

20.8 JSON.stringify()方法可以接受的另外的两个参数为？
用于指定以不同的方式序列化JS对象，第一个参数是过滤器，可以是数组，也可以是函数；第二个参数是一个选项，表示是否在JSON对象中保留缩减。

20.9 为何要定义toJSON()方法？
因为JSON.stringify()方法还不能满足某些对象进行自定义序列化的需求；

21.1通过XHR实现Ajax通信的主要限制是？

21.2跨资源共享的基本思想是？

21.3为何要实现一个跨浏览器的跨域请求？

21.4在跨资源共享之前，有哪些跨域技术？

21.5JSONP由什么组成？

21.6JSONP有什么缺点？

21.7实现Comet的方式有？

21.8如何选择SSE和Web Sockets?

## 二十二至二十五章
22.1 为何JS使用函数指针非常简单？
因为在js中，所有的函数都是对象

22.2 在安全类型检测中，为何使用toString()能保证返回一致的值？
因为原生数组或函数的构造函数名与全局作用域无关

22.3 为何在web开发中区分原生与非原生对象非常重要？
确切知道某个对象有哪些功能

22.4 当使用new调用时，构造函数内用到的this对象会指向哪？
新创建的对象实例

22.5 当没有使用new操作符调用构造函数时，会有何问题？
由于该this对象是运行时绑定，this会映射到全局对象上，导致错误对象属性的意外增加

22.6 如何创建作用域安全的构造函数？
在进行任何更改之前，首先确认this对象是正确类型的实例，如果不是，那么会创建新的实例并返回，避免了在全局对象上意外设置属性

22.7 作用域安全的构造函数存在什么潜在问题？
实现了作用域安全后，就相当于锁定了调用构造函数的环境，如果使用构造函数窃取模式继承且不使用原型链继承，这个继承很可能被破坏；

22.8 惰性载入的技巧用来干啥?
让代码运行得更快，比如存在大量if语句的代码块，即使只有一个if语句，也比没有if语句的慢；

22.9 实现惰性载入的技巧有？
第一种是在函数在被调用时再处理函数，在第一次调用过程中，该函数会被覆盖为另一个按合适方式执行的函数；第二种为在声明函数时就指定适当的函数，基于自执行匿名函数；

22.10 绑定函数一般在什么场景使用？
回调函数，事件处理程序以及setTimeout()和setInterval()，以便将函数作为变量传递时保留代码执行的环境；function bind(fn, context) { return function () { return fn.apply(context, arguments);};}

22.11 为何只有在必要时使用函数绑定？
因为被绑定的函数与普通函数相比，会有更多的开销，比如需要更多的内存，也因为多重调用会慢一些；

22.12 函数柯里化的作用是？
用于创建已经设置好了的一个或多个参数的函数；

22.13 函数柯里化和函数绑定的异同？
都使用一个闭包返回一个函数，而柯里化中函数被调用时，返回函数还需要设置一些传入的参数；

22.14 为何js共享的本质让开发者头疼？
任何任何对象都可以被同一运行环境的代码改变，开发人员很可能意外的修改别人的代码，甚至用不兼容的功能重写原生对象

22.15 不可扩展对象、密封对象和冻结对象的区别？
调用了Object.preventExtensions()方法后，就不可以对该对象添加新的属性和方法了；
而调用了Object.seal()方法后，不仅不可扩展，而且不能删除该对象原有的属性和方法；
最严格的防篡改级别是冻结对象，调用了Object.freeze()方法后，不仅不能扩展和删除，甚至修改该对象的已有属性和方法都可以，只能去读。

22.16 关于定时器需要记住最重要的事情是？
指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码

22.17 为何浏览器要限制JS能控制的内存大小和处理器时间？
防止恶意的web程序吧计算机或者手机搞挂了

22.18 造成脚本长时间运行得原因有？
一是过长的或过深嵌套的函数调用；二是进行大量处理的循环；

22.19 函数节流背后的基本思想是？
某些代码不可以在没有简断的情况下连续重复执行：
function throttle(method, context) {
       clearTimeout(method.tId);
      method.tId = setTimeout( fuction() {
          method.call(context);
      }, 100);
}  如果没有纯context，则默认子全局环境下执行。

22.20 为何当代码中存在多个部分在特定时刻相互交互时，自定义事件非常有用？
使用自定义对象有助于解耦相关对象，保持功能隔绝；

23.1什么是离线web应用？
设备在不能上网的情况下仍然可以运行的应用

23.2 开发离线web应用的三部曲是？
